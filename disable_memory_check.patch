Description: Disable memory-check in SMDS because sysinfo.h is not working 
 on BSD-systems and causes FTBFS. It is better to disable it only on 
 BSD-platforms.
 Or use http://code.google.com/p/sysinfo-bsd/source/browse/sysinfo.c
 for them.
Author: Anton Gladky <gladky.anton@gmail.com>
Bug-Debian: http://bugs.debian.org/623560
Last-Update: 2011-09-24

Index: FreeCAD-0.16/src/3rdParty/salomesmesh/src/SMDS/SMDS_Mesh.cpp
===================================================================
--- FreeCAD-0.16.orig/src/3rdParty/salomesmesh/src/SMDS/SMDS_Mesh.cpp
+++ FreeCAD-0.16/src/3rdParty/salomesmesh/src/SMDS/SMDS_Mesh.cpp
@@ -42,12 +42,6 @@
 #include <iterator>
 using namespace std;
 
-#ifndef WIN32
-#if !(defined(__MACH__) && defined(__APPLE__))
-#include <sys/sysinfo.h>
-#endif
-#endif
-
 // number of added entitis to check memory after
 #define CHECKMEMORY_INTERVAL 1000
 
@@ -61,49 +55,7 @@ using namespace std;
 
 int SMDS_Mesh::CheckMemory(const bool doNotRaise) throw (std::bad_alloc)
 {
-#if (defined(__MACH__) && defined(__APPLE__))
-	return 1000;
-#else	
-#ifndef WIN32
-  struct sysinfo si;
-  int err = sysinfo( &si );
-  if ( err )
-    return -1;
-
-  static int limit = -1;
-  if ( limit < 0 ) {
-    int status = system("SMDS_MemoryLimit"); // it returns lower limit of free RAM
-    if (status >= 0 ) {
-      limit = WEXITSTATUS(status);
-    }
-    if ( limit < 20 )
-      limit = 20;
-    else
-      limit = int( limit * 1.5 );
-#ifdef _DEBUG_
-    MESSAGE ( "SMDS_Mesh::CheckMemory() memory limit = " << limit << " MB" );
-#endif
-  }
-
-  const unsigned long Mbyte = 1024 * 1024;
-  // compute separately to avoid overflow
-  int freeMb =
-    ( si.freeram  * si.mem_unit ) / Mbyte +
-    ( si.freeswap * si.mem_unit ) / Mbyte;
-
-  if ( freeMb > limit )
-    return freeMb - limit;
-
-  if ( doNotRaise )
-    return 0;
-#ifdef _DEBUG_
-  MESSAGE ("SMDS_Mesh::CheckMemory() throws as free memory too low: " << freeMb <<" MB" );
-#endif
-  throw std::bad_alloc();
-#else
-  return -1;
-#endif
-#endif
+return 1000;
 }
 
 ///////////////////////////////////////////////////////////////////////////////
Index: FreeCAD-0.16/src/3rdParty/salomesmesh/src/SMDS/SMDS_MemoryLimit.cpp
===================================================================
--- FreeCAD-0.16.orig/src/3rdParty/salomesmesh/src/SMDS/SMDS_MemoryLimit.cpp
+++ FreeCAD-0.16/src/3rdParty/salomesmesh/src/SMDS/SMDS_MemoryLimit.cpp
@@ -27,11 +27,6 @@
 // This is not done inside a function of SALOME because allocated memory is not returned
 // to the system. (PAL16631)
 //
-#ifndef WIN32
-#if !(defined(__MACH__) && defined(__APPLE__))
-#include <sys/sysinfo.h>
-#endif
-#endif
 
 #ifdef _DEBUG_
 #include <iostream>
@@ -39,39 +34,5 @@
 
 int main (int argc, char ** argv)
 {
-#if (defined(__MACH__) && defined(__APPLE__))
-	//do nothing
-#else
-  // To better understand what is going on here, consult bug [SALOME platform 0019911]
-#ifndef WIN32
-  struct sysinfo si;
-  int err = sysinfo( &si );
-  if ( err )
-    return -1;
-  unsigned long freeRamKb = ( si.freeram  * si.mem_unit ) / 1024;
-
-  // totat RAM size in Gb, float is in order not to have 1 instead of 1.9
-  float totalramGb = float( si.totalram * si.mem_unit ) / 1024 / 1024 / 1024;
-
-  // nb Kbites to allocate at one step. Small nb leads to hung up
-  const int stepKb = int( 5 * totalramGb );
-
-  unsigned long nbSteps = freeRamKb / stepKb * 2;
-  try {
-    while ( nbSteps-- ) {
-      new char[stepKb*1024];
-      err = sysinfo( &si );
-      if ( !err )
-        freeRamKb = ( si.freeram  * si.mem_unit ) / 1024;
-    }
-  } catch (...) {}
-
-// #ifdef _DEBUG_
-//   std::cout << freeRamKb / 1024 << std::endl;
-// #endif
-  return freeRamKb / 1024;
-#endif
-#endif
-
   return -1;
 }
